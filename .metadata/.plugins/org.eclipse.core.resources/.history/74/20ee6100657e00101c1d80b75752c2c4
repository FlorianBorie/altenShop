package back;

import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import io.jsonwebtoken.*;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.sql.*;
import java.util.*;
import io.jsonwebtoken.security.Keys;
import java.security.Key;

public class ProductsHandler implements HttpHandler {
    private final Connection connection; // Connexion à la base de données
    private final String jwtSecret = "uneCleTresLongueDePlusDe32CaracteresPourHS256"; // Clé secrète pour JWT

    public ProductsHandler(Connection connection) {
        this.connection = connection;
    }

    @Override
    public void handle(HttpExchange exchange) throws IOException {
        // Gestion des requêtes OPTIONS pour CORS
        if ("OPTIONS".equalsIgnoreCase(exchange.getRequestMethod())) {
            addCorsHeaders(exchange);
            exchange.sendResponseHeaders(204, -1); // Pas de contenu pour OPTIONS
            return;
        }

        String method = exchange.getRequestMethod(); // Méthode HTTP (GET, POST, etc.)
        String path = exchange.getRequestURI().getPath(); // Chemin de l'URL
        String[] pathParts = path.split("/"); // Découpage du chemin pour gérer /products/{id}

        // Vérifie si l'opération nécessite des droits admin (POST, PUT, DELETE)
        boolean requiresAdmin = !"GET".equalsIgnoreCase(method);
        String email = null;
        boolean isAdmin = false;
        if (requiresAdmin) {
            // Récupération du token JWT dans le header Authorization
            String authHeader = exchange.getRequestHeaders().getFirst("Authorization");
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                sendResponse(exchange, 401, "{\"error\":\"Token manquant\"}");
                return;
            }
            String token = authHeader.substring(7); // Supprimer "Bearer "
            try {
                // Vérification et décodage du JWT
            	Key key = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
            	Claims claims = Jwts.parserBuilder()
            	                    .setSigningKey(key)
            	                    .build()
            	                    .parseClaimsJws(token)
            	                    .getBody();
            	email = claims.getSubject();
            	isAdmin = Boolean.TRUE.equals(claims.get("isAdmin", Boolean.class));
            	if (!isAdmin) {
                    sendResponse(exchange, 403, "{\"error\":\"Accès refusé, admin uniquement\"}");
                    return;
                }
            } catch (JwtException e) {
                sendResponse(exchange, 401, "{\"error\":\"Token invalide\"}");
                return;
            }
        }

        try {
            // Route la requête vers la bonne méthode selon la méthode HTTP
            switch (method) {
                case "GET":
                    if (pathParts.length == 3) handleGetById(exchange, pathParts[2]);
                    else handleGetAll(exchange);
                    break;
                case "POST":
                    handlePost(exchange);
                    break;
                case "PUT":
                    handlePut(exchange, pathParts[2]);
                    break;
                case "DELETE":
                    handleDelete(exchange, pathParts[2]);
                    break;
                default:
                    sendResponse(exchange, 405, "{\"error\":\"Méthode non autorisée\"}");
            }
        } catch (Exception e) {
            sendResponse(exchange, 500, "{\"error\":\"Erreur serveur : " + e.getMessage() + "\"}");
        }
    }

    // Récupère tous les produits
    private void handleGetAll(HttpExchange exchange) throws Exception {
        List<Map<String, String>> products = new ArrayList<>();
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT * FROM products")) {
            while (rs.next()) {
                Map<String, String> product = new HashMap<>();
                product.put("id", String.valueOf(rs.getInt("id")));
                product.put("name", rs.getString("name"));
                product.put("price", rs.getString("price"));
                products.add(product);
            }
        }
        sendResponse(exchange, 200, JsonUtils.listToJson(products));
    }

    // Récupère un produit par son ID
    private void handleGetById(HttpExchange exchange, String idStr) throws Exception {
        int id = Integer.parseInt(idStr);
        Map<String, String> product = null;
        try (PreparedStatement stmt = connection.prepareStatement("SELECT * FROM products WHERE id = ?")) {
            stmt.setInt(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    product = new HashMap<>();
                    product.put("id", String.valueOf(rs.getInt("id")));
                    product.put("name", rs.getString("name"));
                    product.put("price", rs.getString("price"));
                }
            }
        }
        if (product != null) sendResponse(exchange, 200, JsonUtils.mapToJson(product));
        else sendResponse(exchange, 404, "{\"error\":\"Produit non trouvé\"}");
    }

    // Création d'un nouveau produit
    private void handlePost(HttpExchange exchange) throws Exception {
        String body = new String(exchange.getRequestBody().readAllBytes(), StandardCharsets.UTF_8);
        Map<String, String> data = JsonUtils.parseJson(body);
        try (PreparedStatement stmt = connection.prepareStatement(
                "INSERT INTO products (name, price) VALUES (?, ?)", Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, data.get("name"));
            stmt.setObject(2, data.get("price") != null ? Float.valueOf(data.get("price")) : null);
            stmt.executeUpdate();
            try (ResultSet rs = stmt.getGeneratedKeys()) {
                if (rs.next()) data.put("id", String.valueOf(rs.getInt(1)));
            }
        }
        sendResponse(exchange, 201, JsonUtils.mapToJson(data));
    }

    // Mise à jour d'un produit existant
    private void handlePut(HttpExchange exchange, String idStr) throws Exception {
        int id = Integer.parseInt(idStr);
        String body = new String(exchange.getRequestBody().readAllBytes(), StandardCharsets.UTF_8);
        Map<String, String> data = JsonUtils.parseJson(body);
        try (PreparedStatement stmt = connection.prepareStatement(
                "UPDATE products SET name = ?, price = ? WHERE id = ?")) {
            stmt.setString(1, data.get("name"));
            stmt.setObject(2, data.get("price") != null ? Float.valueOf(data.get("price")) : null);
            stmt.setInt(3, id);
            int updated = stmt.executeUpdate();
            if (updated == 0) {
                sendResponse(exchange, 404, "{\"error\":\"Produit non trouvé\"}");
                return;
            }
        }
        data.put("id", String.valueOf(id));
        sendResponse(exchange, 200, JsonUtils.mapToJson(data));
    }

    // Suppression d'un produit
    private void handleDelete(HttpExchange exchange, String idStr) throws Exception {
        int id = Integer.parseInt(idStr);
        try (PreparedStatement stmt = connection.prepareStatement("DELETE FROM products WHERE id = ?")) {
            stmt.setInt(1, id);
            int deleted = stmt.executeUpdate();
            if (deleted == 0) {
                sendResponse(exchange, 404, "{\"error\":\"Produit non trouvé\"}");
                return;
            }
        }
        sendResponse(exchange, 204, ""); // Pas de contenu
    }

    // Envoie une réponse JSON au client
    private void sendResponse(HttpExchange exchange, int status, String response) throws IOException {
        addCorsHeaders(exchange); // Ajouter les headers CORS
        exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
        exchange.sendResponseHeaders(status, response.getBytes(StandardCharsets.UTF_8).length);
        try (OutputStream os = exchange.getResponseBody()) {
            os.write(response.getBytes(StandardCharsets.UTF_8));
        }
    }

    // Ajoute les headers CORS pour autoriser Angular ou d'autres clients
    private void addCorsHeaders(HttpExchange exchange) {
        exchange.getResponseHeaders().add("Access-Control-Allow-Origin", "http://localhost:4200");
        exchange.getResponseHeaders().add("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        exchange.getResponseHeaders().add("Access-Control-Allow-Headers", "Content-Type, Authorization");
    }
}