package back;

import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.sql.*;
import java.util.*;

public class ProductsHandler implements HttpHandler {
    private final Connection connection;    
    private final String jwtSecret = "maCleSecreteSuperSecurisee";


    public ProductsHandler(Connection connection) {
        this.connection = connection;
    }

    @Override
    public void handle(HttpExchange exchange) throws IOException {
        String method = exchange.getRequestMethod();       
        
     // Gestion CORS preflight (OPTIONS)
        if ("OPTIONS".equalsIgnoreCase(method)) {
            exchange.getResponseHeaders().add("Access-Control-Allow-Origin", "http://localhost:4200");
            exchange.getResponseHeaders().add("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
            exchange.getResponseHeaders().add("Access-Control-Allow-Headers", "Content-Type");
            exchange.sendResponseHeaders(204, -1); // 204 No Content pour OPTIONS
            return; // On ne fait rien d'autre
        }

        String method = exchange.getRequestMethod();
        String path = exchange.getRequestURI().getPath();
        String[] pathParts = path.split("/");
        
        boolean requiresAdmin = !"GET".equalsIgnoreCase(method);
        String email = null;
        boolean isAdmin = false;
        if (requiresAdmin) {
            String authHeader = exchange.getRequestHeaders().getFirst("Authorization");
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                sendResponse(exchange, 401, "{\"error\":\"Token manquant\"}");
                return;
            }
            String token = authHeader.substring(7);
            try {
                Claims claims = Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token).getBody();
                email = claims.getSubject();
                isAdmin = Boolean.TRUE.equals(claims.get("isAdmin", Boolean.class));
                if (!isAdmin) {
                    sendResponse(exchange, 403, "{\"error\":\"Accès refusé, admin uniquement\"}");
                    return;
                }
            } catch (JwtException e) {
                sendResponse(exchange, 401, "{\"error\":\"Token invalide\"}");
                return;
            }
        
        try {
            switch (method) {
                case "GET":
                    if (pathParts.length == 3) handleGetById(exchange, pathParts[2]);
                    else handleGetAll(exchange);
                    break;
                case "POST":
                    handlePost(exchange);
                    break;
                case "PUT":
                    handlePut(exchange, pathParts[2]);
                    break;
                case "DELETE":
                    handleDelete(exchange, pathParts[2]);
                    break;
                default:
                    sendResponse(exchange, 405, "{\"error\":\"Méthode non autorisée\"}");
            }
        } catch (NumberFormatException e) {
            sendResponse(exchange, 400, "{\"error\":\"ID invalide\"}");
        } catch (SQLException e) {
            sendResponse(exchange, 500, "{\"error\":\"Erreur base de données : " + e.getMessage() + "\"}");
        } catch (IOException e) {
            sendResponse(exchange, 500, "{\"error\":\"Erreur lecture/écriture : " + e.getMessage() + "\"}");
        } catch (IllegalArgumentException e) {
            sendResponse(exchange, 400, "{\"error\":\"Données invalides : " + e.getMessage() + "\"}");
        } catch (Exception e) {
            sendResponse(exchange, 500, "{\"error\":\"Erreur inconnue : " + e.getMessage() + "\"}");
        }
    }
    
    // Affiche tous les elements
    private void handleGetAll(HttpExchange exchange) throws Exception {
        List<Map<String, String>> products = new ArrayList<>();
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT * FROM products")) {
            while (rs.next()) {
                Map<String, String> product = new HashMap<>();
                product.put("id", String.valueOf(rs.getInt("id")));
                product.put("name", rs.getString("name"));
                product.put("price", rs.getString("price"));
                products.add(product);
            }
        }
        sendResponse(exchange, 200, JsonUtils.listToJson(products));
    }

    // Affiche un element
    private void handleGetById(HttpExchange exchange, String idStr) throws Exception {
        int id = Integer.parseInt(idStr);
        Map<String, String> product = null;
        try (PreparedStatement stmt = connection.prepareStatement("SELECT * FROM products WHERE id = ?")) {
            stmt.setInt(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    product = new HashMap<>();
                    product.put("id", String.valueOf(rs.getInt("id")));
                    product.put("name", rs.getString("name"));
                    product.put("price", rs.getString("price"));
                }
            }
        }
        if (product != null) sendResponse(exchange, 200, JsonUtils.mapToJson(product));
        else sendResponse(exchange, 404, "{\"error\":\"Produit non trouvé\"}");
    }

    //Ajout un element
    private void handlePost(HttpExchange exchange) throws Exception {
        String body = new String(exchange.getRequestBody().readAllBytes(), StandardCharsets.UTF_8);
        Map<String, String> data = JsonUtils.parseJson(body);

        try (PreparedStatement stmt = connection.prepareStatement(
                "INSERT INTO products (name, price) VALUES (?, ?)", Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, data.get("name"));
            stmt.setObject(2, data.get("price") != null ? Float.valueOf(data.get("price")) : null);
            stmt.executeUpdate();

            try (ResultSet rs = stmt.getGeneratedKeys()) {
                if (rs.next()) data.put("id", String.valueOf(rs.getInt(1)));
            }
        }
        sendResponse(exchange, 201, JsonUtils.mapToJson(data));
    }

    //Mettre à jours un element
    private void handlePut(HttpExchange exchange, String idStr) throws Exception {
        int id = Integer.parseInt(idStr);
        String body = new String(exchange.getRequestBody().readAllBytes(), StandardCharsets.UTF_8);
        Map<String, String> data = JsonUtils.parseJson(body);

        try (PreparedStatement stmt = connection.prepareStatement(
                "UPDATE products SET name = ?, price = ? WHERE id = ?")) {
            stmt.setString(1, data.get("name"));
            stmt.setObject(2, data.get("price") != null ? Float.valueOf(data.get("price")) : null);
            stmt.setInt(3, id);
            int updated = stmt.executeUpdate();
            if (updated == 0) {
                sendResponse(exchange, 404, "{\"error\":\"Produit non trouvé\"}");
                return;
            }
        }
        data.put("id", String.valueOf(id));
        sendResponse(exchange, 200, JsonUtils.mapToJson(data));
    }

    //Supprimer un element
    private void handleDelete(HttpExchange exchange, String idStr) throws Exception {
        int id = Integer.parseInt(idStr);
        try (PreparedStatement stmt = connection.prepareStatement("DELETE FROM products WHERE id = ?")) {
            stmt.setInt(1, id);
            int deleted = stmt.executeUpdate();
            if (deleted == 0) {
                sendResponse(exchange, 404, "{\"error\":\"Produit non trouvé\"}");
                return;
            }
        }
        sendResponse(exchange, 204, "");
    }

    private void sendResponse(HttpExchange exchange, int status, String response) throws IOException {
        // En-têtes CORS
        exchange.getResponseHeaders().add("Access-Control-Allow-Origin", "http://localhost:4200");
        exchange.getResponseHeaders().add("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        exchange.getResponseHeaders().add("Access-Control-Allow-Headers", "Content-Type");

        exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
        exchange.sendResponseHeaders(status, response.getBytes(StandardCharsets.UTF_8).length);
        try (OutputStream os = exchange.getResponseBody()) {
            os.write(response.getBytes(StandardCharsets.UTF_8));
        }
    }
}
